//! Weekly Reflection Module
//!
//! Implements the LEARN phase of the agentic system.
//! Generates weekly reflections on career progress, plan adaptations,
//! and next-step suggestions.

use super::memory::{CareerMemory, MemoryEvent, MemoryEventType, MemoryStore};
use super::planner::CareerRoadmap;
use chrono::{DateTime, Duration, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// ============================================================
// REFLECTION STRUCTURES
// ============================================================

/// A weekly reflection generated by the agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WeeklyReflection {
    pub id: String,
    pub user_id: String,
    pub generated_at: DateTime<Utc>,
    /// Week start date
    pub week_start: DateTime<Utc>,
    /// Week end date
    pub week_end: DateTime<Utc>,
    /// Main reflection text
    pub summary: String,
    /// What changed this week
    pub changes: Vec<String>,
    /// Why the plan adapted
    pub adaptations: Vec<String>,
    /// What the agent suggests next
    pub suggestions: Vec<String>,
    /// Metrics for the week
    pub metrics: WeeklyMetrics,
}

/// Metrics computed for the week
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct WeeklyMetrics {
    /// Steps completed this week
    pub steps_completed: u32,
    /// Steps added this week
    pub steps_added: u32,
    /// Steps modified this week
    pub steps_modified: u32,
    /// Total events recorded
    pub total_events: u32,
    /// Overall progress percentage (0-100)
    pub progress_percentage: f32,
}

// ============================================================
// REFLECTION GENERATOR
// ============================================================

/// Configuration for reflection generation
#[derive(Debug, Clone)]
pub struct ReflectionConfig {
    /// Whether to use LLM for generating reflection text
    pub use_llm: bool,
    /// LLM model to use (if enabled)
    pub llm_model: Option<String>,
}

impl Default for ReflectionConfig {
    fn default() -> Self {
        Self {
            use_llm: false,
            llm_model: None,
        }
    }
}

/// Generates weekly reflections
pub struct ReflectionGenerator {
    config: ReflectionConfig,
}

impl ReflectionGenerator {
    pub fn new(config: ReflectionConfig) -> Self {
        Self { config }
    }

    /// Generate a weekly reflection based on memory and current plan
    pub fn generate_weekly_reflection(
        &self,
        memory: &CareerMemory,
        roadmap: &CareerRoadmap,
    ) -> WeeklyReflection {
        let now = Utc::now();
        let week_start = now - Duration::days(7);
        let week_end = now;

        // Get events from this week
        let week_events: Vec<&MemoryEvent> = memory.events_since(7);

        // Compute metrics
        let metrics = self.compute_metrics(&week_events, roadmap);

        // Extract changes
        let changes = self.extract_changes(&week_events);

        // Analyze adaptations
        let adaptations = self.analyze_adaptations(&week_events, roadmap);

        // Generate suggestions
        let suggestions = self.generate_suggestions(roadmap, &metrics);

        // Generate summary text
        let summary = if self.config.use_llm {
            self.generate_llm_summary(&changes, &adaptations, &suggestions)
        } else {
            self.generate_rule_based_summary(&changes, &adaptations, &suggestions, &metrics)
        };

        WeeklyReflection {
            id: Uuid::new_v4().to_string(),
            user_id: memory.user_id.clone(),
            generated_at: now,
            week_start,
            week_end,
            summary,
            changes,
            adaptations,
            suggestions,
            metrics,
        }
    }

    fn compute_metrics(&self, events: &[&MemoryEvent], roadmap: &CareerRoadmap) -> WeeklyMetrics {
        let steps_completed = events
            .iter()
            .filter(|e| e.event_type == MemoryEventType::StepCompleted)
            .count() as u32;

        let steps_added = events
            .iter()
            .filter(|e| matches!(e.event_type, MemoryEventType::PlanModified) 
                && e.description.contains("Added"))
            .count() as u32;

        let steps_modified = events
            .iter()
            .filter(|e| e.event_type == MemoryEventType::PlanModified)
            .count() as u32;

        let total_steps = roadmap.steps.len() as f32;
        let completed_steps = roadmap.steps.iter()
            .filter(|s| s.status == "completed")
            .count() as f32;

        let progress_percentage = if total_steps > 0.0 {
            (completed_steps / total_steps) * 100.0
        } else {
            0.0
        };

        WeeklyMetrics {
            steps_completed,
            steps_added,
            steps_modified,
            total_events: events.len() as u32,
            progress_percentage,
        }
    }

    fn extract_changes(&self, events: &[&MemoryEvent]) -> Vec<String> {
        events
            .iter()
            .filter(|e| matches!(
                e.event_type,
                MemoryEventType::StepCompleted
                    | MemoryEventType::PlanModified
                    | MemoryEventType::ResumeUploaded
                    | MemoryEventType::GoalSet
            ))
            .map(|e| e.description.clone())
            .collect()
    }

    fn analyze_adaptations(&self, events: &[&MemoryEvent], _roadmap: &CareerRoadmap) -> Vec<String> {
        let mut adaptations = Vec::new();

        // Check for plan modifications
        let modifications: Vec<_> = events
            .iter()
            .filter(|e| e.event_type == MemoryEventType::PlanModified)
            .collect();

        if !modifications.is_empty() {
            adaptations.push(format!(
                "Your roadmap was adjusted {} time(s) this week based on your progress and feedback.",
                modifications.len()
            ));
        }

        // Check for goal updates
        let goal_updates: Vec<_> = events
            .iter()
            .filter(|e| e.event_type == MemoryEventType::GoalUpdated)
            .collect();

        if !goal_updates.is_empty() {
            adaptations.push("Your career goal was updated, and the plan was realigned accordingly.".to_string());
        }

        // Check for skipped steps
        let skipped: Vec<_> = events
            .iter()
            .filter(|e| e.event_type == MemoryEventType::StepSkipped)
            .collect();

        if !skipped.is_empty() {
            adaptations.push(format!(
                "{} step(s) were skipped and may be revisited later.",
                skipped.len()
            ));
        }

        if adaptations.is_empty() {
            adaptations.push("Your plan remained stable this week with steady progress.".to_string());
        }

        adaptations
    }

    fn generate_suggestions(&self, roadmap: &CareerRoadmap, metrics: &WeeklyMetrics) -> Vec<String> {
        let mut suggestions = Vec::new();

        // Find next incomplete step
        if let Some(next_step) = roadmap.steps.iter().find(|s| s.status == "not_started") {
            suggestions.push(format!(
                "Focus on your next step: '{}' (estimated {} weeks)",
                next_step.title, next_step.estimated_weeks
            ));
        }

        // Progress-based suggestions
        if metrics.progress_percentage > 75.0 {
            suggestions.push("You're making excellent progress! Consider setting a more ambitious goal.".to_string());
        } else if metrics.progress_percentage < 25.0 && metrics.steps_completed == 0 {
            suggestions.push("Consider breaking down your first step into smaller tasks to build momentum.".to_string());
        }

        // Check for steps in progress too long
        let in_progress: Vec<_> = roadmap.steps.iter()
            .filter(|s| s.status == "in_progress")
            .collect();

        if in_progress.len() > 2 {
            suggestions.push("You have multiple steps in progress. Consider focusing on completing one before starting others.".to_string());
        }

        // Deferred steps suggestion
        if !roadmap.deferred.is_empty() {
            suggestions.push(format!(
                "You have {} deferred step(s). Review them periodically to see if they're now achievable.",
                roadmap.deferred.len()
            ));
        }

        if suggestions.is_empty() {
            suggestions.push("Keep up the great work! Continue following your roadmap.".to_string());
        }

        suggestions
    }

    fn generate_rule_based_summary(
        &self,
        changes: &[String],
        adaptations: &[String],
        suggestions: &[String],
        metrics: &WeeklyMetrics,
    ) -> String {
        let mut parts = Vec::new();

        // Progress summary
        if metrics.steps_completed > 0 {
            parts.push(format!(
                "This week you completed {} step(s) and are now {:.0}% through your career roadmap.",
                metrics.steps_completed, metrics.progress_percentage
            ));
        } else {
            parts.push(format!(
                "This week you're at {:.0}% progress on your career roadmap.",
                metrics.progress_percentage
            ));
        }

        // Changes summary
        if !changes.is_empty() && changes.len() <= 3 {
            parts.push(format!("Key changes: {}", changes.join("; ")));
        } else if changes.len() > 3 {
            parts.push(format!("You made {} significant changes to your plan.", changes.len()));
        }

        // Adaptation summary
        if let Some(adaptation) = adaptations.first() {
            parts.push(adaptation.clone());
        }

        // Primary suggestion
        if let Some(suggestion) = suggestions.first() {
            parts.push(format!("Next: {}", suggestion));
        }

        parts.join(" ")
    }

    fn generate_llm_summary(
        &self,
        _changes: &[String],
        _adaptations: &[String],
        _suggestions: &[String],
    ) -> String {
        // Placeholder for LLM integration
        // In production, this would call an LLM API
        "Weekly reflection generated by AI assistant. (LLM integration pending)".to_string()
    }
}

// ============================================================
// REFLECTION STORE
// ============================================================

/// Store for persisting reflections
pub struct ReflectionStore {
    reflections: std::sync::Mutex<Vec<WeeklyReflection>>,
}

impl ReflectionStore {
    pub fn new() -> Self {
        Self {
            reflections: std::sync::Mutex::new(Vec::new()),
        }
    }

    pub fn save_reflection(&self, reflection: WeeklyReflection) {
        let mut store = self.reflections.lock().unwrap();
        store.push(reflection);
    }

    pub fn get_latest(&self, user_id: &str) -> Option<WeeklyReflection> {
        let store = self.reflections.lock().unwrap();
        store
            .iter()
            .filter(|r| r.user_id == user_id)
            .max_by_key(|r| r.generated_at)
            .cloned()
    }

    pub fn get_all(&self, user_id: &str) -> Vec<WeeklyReflection> {
        let store = self.reflections.lock().unwrap();
        store
            .iter()
            .filter(|r| r.user_id == user_id)
            .cloned()
            .collect()
    }
}

impl Default for ReflectionStore {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================================
// HELPER FUNCTIONS
// ============================================================

/// Generate and store a weekly reflection
pub fn generate_and_store_reflection(
    generator: &ReflectionGenerator,
    memory: &CareerMemory,
    roadmap: &CareerRoadmap,
    store: &ReflectionStore,
    memory_store: &MemoryStore,
) -> WeeklyReflection {
    let reflection = generator.generate_weekly_reflection(memory, roadmap);
    
    // Store the reflection
    store.save_reflection(reflection.clone());
    
    // Record in memory
    let _ = super::memory::record_reflection(
        memory_store,
        &reflection.user_id,
        &reflection.summary,
    );
    
    reflection
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::agent::planner::{CareerPlanner, PlannerConfig, PlannerInput};
    use crate::agent::types::{CareerGoal, CareerRule, ResumeData};
    use std::collections::HashSet;

    #[test]
    fn test_reflection_generation() {
        let generator = ReflectionGenerator::new(ReflectionConfig::default());
        
        // Create a simple memory
        let mut memory = CareerMemory::new("test_user");
        memory.add_event(MemoryEvent::new(
            "test_user",
            MemoryEventType::StepCompleted,
            "Completed: Learn Python basics",
        ));

        // Create a simple roadmap
        let planner = CareerPlanner::new(PlannerConfig::default());
        let input = PlannerInput {
            resume: ResumeData {
                user_id: "test_user".to_string(),
                ..Default::default()
            },
            assessments: Vec::new(),
            goal: CareerGoal::new("test_user", "Test Goal"),
            available_rules: vec![CareerRule::new("test", "Test Step", "technical_skill")],
            deferred_steps: HashSet::new(),
        };
        let roadmap = planner.generate_roadmap(&input);

        // Generate reflection
        let reflection = generator.generate_weekly_reflection(&memory, &roadmap);
        
        assert!(!reflection.summary.is_empty());
        assert_eq!(reflection.user_id, "test_user");
    }
}

# CORE.md

## Core Engine Architecture

NoGap's core engine (`nogap_core`) provides a three-tier policy enforcement system with trait-based abstractions for cross-platform operation. The orchestration layer in `engine.rs` exposes three primary functions: `audit()`, `remediate()`, and `rollback()`. These functions route platform-specific operations through compile-time gates (`cfg(target_os)`), dispatching to `platforms::windows` or `platforms::linux` modules. The engine uses trait abstractions (`PolicyStateProvider`, `SnapshotProvider`) to separate orchestration logic from platform implementations, enabling both production and mock providers for testing. Each platform module implements specialized traits (`Registry`, `ServiceManager`, `SysctlProvider`, `PackageProvider`) to encapsulate OS-specific APIs. This design ensures the engine remains testable and maintainable while supporting complex policy enforcement across Windows and Linux.

## Policy Parser

The policy parser (`policy_parser.rs`) deserializes YAML definitions into structured `Policy` objects using `serde_yaml`. Each policy contains 30+ optional fields including `id`, `platform`, `check_type`, `target_path`, `value_name`, `expected_state`, `set_value`, `regex`, `service_name`, and `remediate_type`. The `ExpectedState` enum supports both simple string comparisons (`String("stopped_disabled")`) and operator-based evaluations (`Map{operator: "gte", value: 24}`), enabling flexible policy validation logic. The `resolve_policy_path()` function standardizes policy file discovery across environments (repository-relative paths for dev, `C:\ProgramData\NoGap` on Windows, `/etc/nogap` on Linux). Policies are loaded via `load_policy()`, which opens a buffered reader and parses the entire YAML array. This structure allows policies to express complex requirements (registry DWORD values, sysctl parameters, file regex patterns, service states) in a unified schema.

## Audit Engine

The audit engine (`engine::audit()`) iterates through policies, routing each by platform to `windows::audit_policy()` or `linux::audit_policy()` dispatchers. These dispatchers match `check_type` to invoke specialized check functions. On Windows, `check_type` values include `registry_key` (DWORD/String comparisons via `Registry` trait), `local_policy` (secedit INF parsing via `SeceditExecutor`), and `service_status` (sc.exe queries via `ServiceManager`). On Linux, check types include `sysctl` (kernel parameter validation), `file_regex` (multiline pattern matching), `file_permissions` (Unix mode bit checks), and `login_defs` (/etc/login.defs parsing). Each check function returns an `AuditResult` with `policy_id`, `passed` boolean, and descriptive `message`. The engine aggregates results into a `Vec<AuditResult>`, providing a complete compliance snapshot. Policy-specific handlers (41 total: 18 Windows, 23 Linux) route by `policy.id` for policies requiring custom logic beyond generic check types. The audit engine is purely read-only, performing no system modifications.

## Remediation Engine

The remediation engine (`engine::remediate()`) enforces policy compliance with snapshot-wrapped atomic operations. For each policy, it first saves a "BEFORE" snapshot via `snapshot_provider.save_snapshot(policy_id, "BEFORE", context)`, capturing current state. The engine then matches `(platform, policy.id)` to invoke one of 41 policy-specific handlers (e.g., Windows A.1.a.i for password history, Linux B.2.a.i for IP forwarding). Each handler creates platform-specific provider instances (`RealRegistry`, `RealServiceManager`, `RealSysctlProvider`) and calls remediation functions. Windows remediation includes registry DWORD/String writes, secedit INF generation and application, and service stop/disable operations. Linux remediation includes sysctl writes (`sysctl -w`), file regex replacement with atomic `.tmp` writes, chmod operations, and package removal (dpkg/apt-get or rpm/yum). After remediation, the engine saves an "AFTER" snapshot. All remediation operations enforce privilege requirements via `ensure_admin()` (Windows) or `ensure_root()` (Linux) before execution, returning `Err("Privileges required")` if checks fail. The function returns `Vec<RemediateResult>` with `Success{policy_id, message}` or `Failed{policy_id, message}` variants.

## Rollback Engine

The rollback engine (`engine::rollback()`) restores previous policy states using SQLite snapshots. Given a `policy_id`, it queries the snapshot database via `snapshot::load_last_snapshot(conn, policy_id)` to retrieve the most recent "BEFORE" state as a `serde_json::Value`. The engine locates the policy definition in the policies array, then invokes `state_provider.apply_state(&policy, rollback_state.value)`. The `DefaultPolicyStateProvider` implements `apply_state()` for six check types: `registry_key` (restores DWORD/String via `apply_registry_state`), `local_policy` (regenerates secedit INF via `apply_secedit_state`), `service_status` (restarts/disables via `apply_service_state`), `sysctl_key` (writes kernel params via `apply_sysctl_state`), `file_content` (rewrites files via `apply_file_state`), and `file_permissions` (restores mode bits). Each platform-specific helper deserializes the JSON value, reconstructs the original state, and applies it using the appropriate trait (`Registry::set_dword`, `SysctlProvider::set_value`, etc.). The function returns a `RollbackResult` with `policy_id`, `success` boolean, and `message`, enabling audit trails of rollback operations.

## Snapshot System

The snapshot system (`snapshot.rs`) provides SQLite-based state persistence with structured diffs. The `init_db()` function creates a `snapshots` table with columns: `id`, `policy_id`, `timestamp`, `description`, `before_state`, `after_state`. The `save_snapshot()` function records state pairs with Unix timestamps, enabling temporal tracking. For rollback support, `save_rollback()` stores policy-specific state with empty `after_state`, while `load_last_snapshot()` queries the most recent entry by `policy_id` and deserializes `before_state` into a `RollbackState` struct containing `policy_id` and `serde_json::Value`. The system includes `compare_snapshots()` for diff generation between two snapshot IDs, and `diff_snapshot_states()` for comparing `before_state` vs `after_state` within a single snapshot. The `SnapshotDiff` struct categorizes changes into `added`, `removed`, and `changed` fields, with `display()` providing formatted output (âž• Added, âž– Removed, ðŸ”„ Modified). All state serialization uses JSON, allowing flexible storage of registry values, file contents, sysctl parameters, and service configurations. The snapshot database resides at `snapshots.db` in the working directory.

## OSTree-lite Integration

The OSTree-lite module (`ostree_lite.rs`) implements content-addressable storage (CAS) for secure update distribution via USB. Objects are stored with SHA256-based sharding (`objects/<first2>/<remaining62>`), enabling efficient lookups via `object_path_for_hash()`. The `discover_usb_repos()` function scans platform-specific mount points (Windows drive letters D:-Z:, Linux `/media` and `/run/media`, macOS `/Volumes`) for `aegis_repo/` directories. Manifests (`refs/heads/production.manifest`) list all objects with hashes and sizes, signed with Ed25519 signatures stored in `refs/heads/production.sig`. The `read_manifest()` function parses manifests and returns raw bytes for signature verification via `verify_manifest()`, which uses `ed25519_dalek` to validate against trusted keys from `~/.nogap/trusted_keys.json` or a hardcoded fallback. The `pull_objects()` function streams objects from USB to local CAS with incremental SHA256 verification, atomic `.tmp` writes, and per-object size limits (default 100 MB). The `install_manifest()` function atomically updates local refs after verifying all objects exist. Export operations (`export_commit_to_target()`) enforce removable media checks on Windows and require explicit user confirmation to prevent accidental writes. The integration enables air-gapped policy updates without network connectivity.

## Security Model Inside Core

NoGap's core security model enforces multiple layers of protection. **Privilege Enforcement**: All remediation operations call `ensure_admin()` (Windows) or `ensure_root()` (Linux) before execution. Windows admin detection uses a `winreg` write test to `HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run` with `KEY_WRITE` flag. Linux root detection uses `unsafe { libc::geteuid() } == 0`. Both functions return `Err()` if privileges are insufficient, preventing unauthorized changes. **Binary Integrity**: The `self_check.rs` module computes SHA256 hashes of the running executable and compares against `expected_hash.bin` embedded at build time. The `start_integrity_check()` function spawns background verification via `crossbeam_channel`, allowing non-blocking checks with `poll_integrity_status()`. The `critical_alert()` callback triggers on hash mismatches, indicating tampering. **Symlink Protection**: The `check_local_cas()` function uses `symlink_metadata()` to reject symlinks, preventing directory traversal attacks. File operations use canonical path checks to ensure paths remain within expected boundaries. **Atomic Operations**: File writes use `.tmp` intermediate files with atomic `rename()`, preventing partial writes. The snapshot system wraps all remediations with BEFORE/AFTER state capture, enabling complete audit trails and rollback capabilities. This multi-layered approach mitigates privilege escalation, code injection, and unauthorized modifications.

**Stage 3 complete.**

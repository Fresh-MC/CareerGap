# SWOT.md

## Strengths

**Technical Architecture**: NoGap leverages a three-tier Rust architecture with trait-based abstractions (`PolicyStateProvider`, `SnapshotProvider`) that enable compile-time platform dispatch while maintaining testability. The `nogap_core` engine separates orchestration logic from platform implementations via specialized traits (`Registry`, `ServiceManager`, `SysctlProvider`), ensuring maintainability as new platforms are added. The OSTree-lite CAS implementation provides cryptographically verified updates with SHA256 object naming and Ed25519 signature validation, enabling secure air-gapped distribution via USB without network dependencies.

**Security Model**: Multi-layered protection includes privilege enforcement (`ensure_admin()`/`ensure_root()` checks before all write operations), binary integrity verification (SHA256 self-checks with `crossbeam_channel` background threads), symlink attack prevention (`symlink_metadata()` guards), and atomic file operations (`.tmp` writes with `rename()` for rollback safety). Snapshot-wrapped remediation creates BEFORE/AFTER audit trails in SQLite with JSON state serialization, enabling complete rollback for any policy change. The snapshot system captures registry DWORDs, secedit INF contents, sysctl parameters, file permissions, and service states with Unix timestamps for temporal tracking.

**User Experience**: The dual-interface approach serves both interactive operators and automation pipelines. The TUI (`ratatui` + `crossterm`) provides vim-style navigation (`j`/`k`), real-time search (`/`), multi-select batch operations (`m` + `Space`), and 7 specialized screens (Dashboard, Details, Help, Snapshots, Filters, Diffs, Batch Menu) with modal overlays for blocking operations. The Tauri desktop app (8.7 MB bundle) delivers native performance with HTML/CSS/JS frontend and Rust IPC backend, supporting 1600+ policies across Windows/Linux with one-click remediation. The `--json` flag enables CI/CD integration with structured `CliReport` output (timestamp, compliance_score, results array).

## Weaknesses

**Platform Coverage Gaps**: Windows auditing relies on `sc.exe`, `reg.exe`, and `secedit` CLI tools rather than native APIs, introducing parsing brittleness and performance overhead. The `SeceditExecutor` generates temporary INF files and shells out to `secedit /export` and `/configure`, which fail if system tools are missing or modified. Linux implementations similarly depend on `systemctl`, `sysctl`, `chmod`, and `grep` availability. macOS support is minimal (only OSTree USB discovery for `/Volumes`), with no policies defined in `policies.yaml`. The policy parser lacks runtime validation beyond YAML deserialization—invalid `check_type` values or missing required fields cause panics rather than graceful errors.

**Rollback Limitations**: The rollback engine (`engine::rollback()`) supports only 6 check types (`registry_key`, `local_policy`, `service_status`, `sysctl_key`, `file_content`, `file_permissions`), leaving 35+ specialized policy handlers without automatic state restoration. Rollback fails silently if the policy definition has changed between snapshot creation and restoration, as it uses `policy_id` matching without schema versioning. The snapshot database (`snapshots.db`) grows unbounded—no pruning or retention policies exist, potentially filling disk on systems with frequent remediation cycles. Complex policies requiring multi-step rollback (e.g., package removal + config rewrite + service restart) lack transactional guarantees, possibly leaving systems in inconsistent states if partial rollback fails.

## Opportunities

**API Modernization**: Replacing Windows CLI tools with native APIs (`winreg` crate for registry, Windows Security Policy API for local policies, `windows-service` for service control) would eliminate parsing fragility and improve performance by 10-100x. Linux privilege management could adopt `polkit` integration for fine-grained authorization rather than blanket root requirements. Cross-platform file monitoring (`notify` crate) would enable real-time compliance drift detection, alerting operators when policies become non-compliant between audit cycles.

**Enterprise Features**: Centralized management with a REST API backend (Axum/Rocket) could aggregate compliance data from distributed NoGap agents via TLS-authenticated JSON reporting. Role-based access control (RBAC) would allow read-only auditors vs. remediators with policy-specific permissions. Scheduled audits (cron/systemd timer integration) with email/webhook notifications (via `lettre`/`reqwest`) would automate compliance monitoring. PDF/HTML report generation (`headless_chrome`/`weasyprint` via FFI) with executive summaries, trending charts (pass rate over time), and evidence attachments would satisfy audit requirements.

**Policy Expansion**: The current 1600+ policies focus on CIS benchmarks but could expand to NIST 800-53, PCI DSS, HIPAA, and SOC2 frameworks. Custom policy creation via YAML template editor in the dashboard (with schema validation) would allow organizations to encode proprietary security requirements. Cloud platform support (AWS Config Rules via `rusoto`, Azure Policy via `azure_sdk_for_rust`, GCP Cloud Asset Inventory) would unify on-prem and cloud compliance. Container/Kubernetes policy checks (`kube-rs` for API access, OPA integration for Rego policy evaluation) would extend coverage to modern infrastructure.

## Threats

**Attack Surface**: NoGap requires elevated privileges (admin/root) for remediation, making it a high-value target for privilege escalation attacks. If an attacker compromises the binary or policy YAML files, they could inject malicious remediations (e.g., disable firewall, create backdoor users, exfiltrate data). The OSTree-lite signature verification relies on trusted keys in `~/.nogap/trusted_keys.json` or hardcoded fallback—key compromise enables arbitrary policy injection. The dashboard's Tauri webview (`WebKit2GTK`/`WKWebView`/`WebView2`) inherits browser vulnerabilities; XSS in policy descriptions or snapshot diffs could escalate to IPC command injection if sanitization fails.

**Supply Chain Risks**: Dependency vulnerabilities in 50+ crates (e.g., `serde_yaml`, `rusqlite`, `crossbeam`, `ed25519-dalek`) require continuous auditing via `cargo-audit`. Build toolchain compromise (rustc, LLVM, linker) could inject backdoors undetectable in source review. Third-party policy definitions downloaded via USB repos lack chain-of-custody tracking—malicious insiders could embed destructive policies disguised as security improvements. The single-signature model (one Ed25519 key pair) lacks threshold signing or hardware security module (HSM) protection, creating a single point of failure.

**Operational Hazards**: Mass remediation without testing (batch mode with 1600+ policies) could render systems unbootable if incompatible policies conflict (e.g., secedit INF parsing failures crash Windows Group Policy engine). The lack of dry-run mode (`--dry-run` flag missing) forces operators to audit-then-remediate rather than preview changes. Snapshot database corruption (SQLite file corruption, disk full during write) prevents rollback, leaving no recovery path. Air-gapped environments lack vulnerability patching mechanisms—critical flaws in NoGap itself or OS components require manual USB distribution of updates, introducing lag time measured in weeks/months.

**Mitigations**: Implement code signing for binaries (Apple notarization, Windows Authenticode), multi-signature policy manifests (3-of-5 threshold via `frost-ed25519`), read-only mounts for policy files (`chmod 444`, SELinux/AppArmor policies), and sandboxed remediation (systemd dynamic users, Linux namespaces). Add `--dry-run` simulation mode, pre-remediation compatibility checks (policy conflict detection), automatic snapshot pruning (retain last N per policy, configurable via `retention_policy.yaml`), and SQLite WAL mode with checksummed backups. Integrate SBOM generation (`cargo-sbom`) and continuous `cargo-audit` in CI/CD to track dependency CVEs.

**Stage 5 documentation complete.**
